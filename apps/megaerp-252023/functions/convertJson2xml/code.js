function convertJson2xml(pJson, pOptions) {
    function a(e) { return Array.isArray ? Array.isArray(e) : "[object Array]" === (t = e, Object.prototype.toString.call(t)); var t } function v(e) { var t = function (e, t) { e in t && "boolean" == typeof t[e] || (t[e] = !1) }, n = function (e) { (!("spaces" in e) || "number" != typeof e.spaces && "string" != typeof e.spaces) && (e.spaces = 0) }, r = function (e, t) { e + "Key" in t && "string" == typeof t[e + "Key"] || (t[e + "Key"] = t.compact ? "_" + e : e) }, a = function (e, t) { return e + "Fn" in t }, c = function (e) { var t, n = {}; for (t in e) e.hasOwnProperty(t) && (n[t] = e[t]); return n }(e); return t("compact", c), n(c), "number" == typeof c.spaces && (c.spaces = Array(c.spaces + 1).join(" ")), r("attributes", c), r("text", c), r("comment", c), r("type", c), r("elements", c), a("cdata", c), a("attributeName", c), a("attributeValue", c), a("attributes", c), c } var cE, cN; function y(e, t, n) { return (!n && e.spaces ? "\n" : "") + Array(t + 1).join(e.spaces) } function z(e, t, n) { var r, a, c, i, s = []; for (r in e) e.hasOwnProperty(r) && null !== e[r] && void 0 !== e[r] && (i = t.noQ && "string" != typeof e[r] ? "" : '"', a = (a = "" + e[r]).replace(/"/g, "&quot;"), c = "aNFn" in t ? t.aNFn(r, a, cN, cE) : r, s.push(t.spaces && t.indentAttributes ? y(t, n + 1, !1) : " "), s.push(c + "=" + i + ("aVFn" in t ? t.aVFn(a, r, cN, cE) : a) + i)); return e && Object.keys(e).length && t.spaces && t.indentAttributes && s.push(y(t, n, !1)), s.join("") } function p(e, t, n) { return cE = e, cN = "xml", t.ignoreDeclaration ? "" : "<?xml" + z(e[t.attributesKey], t, n) + "?>" } function g(e, t, n) { if (t.ignoreInstruction) return ""; var r; for (r in e) if (e.hasOwnProperty(r)) break; var a = "iNF" in t ? t.iNF(r, e[r], cN, cE) : r; if ("object" == typeof e[r]) return cE = e, cN = a, "<?" + a + z(e[r][t.attributesKey], t, n) + "?>"; var c = e[r] ? e[r] : ""; return "iF" in t && (c = t.iF(c, r, cN, cE)), "<?" + a + (c ? " " + c : "") + "?>" } function b(e, t) { return t.ic ? "" : "\x3c!--" + ("cmFn" in t ? t.cmFn(e, cN, cE) : e) + "--\x3e" } function m(e, t) { return t.ignoreCdata ? "" : "<![CDATA[" + ("cdFn" in t ? t.cdFn(e, cN, cE) : e.replace("]]>", "]]]]><![CDATA[>")) + "]]>" } function l(e, t) { return t.ignoreDoctype ? "" : "<!DOCTYPE " + ("dtFn" in t ? t.dtFn(e, cN, cE) : e) + ">" } function j(e, t) { return t.it ? "" : (e = (e = (e = "" + e).replace(/&amp;/g, "&")).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), "tFn" in t ? t.tFn(e, cN, cE) : e) } function h(e, t, n) { var r; for (r in e) if (e.hasOwnProperty(r)) switch (r) { case t.parentKey: case t.attributesKey: break; case t.textKey: if (t.indentText || n) return !0; break; case t.cdataKey: if (t.indentCdata || n) return !0; break; case t.Key: if (t.indentInstruction || n) return !0; break; case t.doctypeKey: case t.commentKey: default: return !0 }return !1 } function t(e, t, n, r, a) { cE = e, cN = t; t = "eNFn" in n ? n.eNFn(t, e) : t; if (null == e || "" === e) return "ftef" in n && n.ftef(t, e) || n.ft ? "<" + t + "></" + t + ">" : "<" + t + "/>"; var c = []; if (t) { if (c.push("<" + t), "object" != typeof e) return c.push(">" + j(e, n) + "</" + t + ">"), c.join(""); e[n.attributesKey] && c.push(z(e[n.attributesKey], n, r)); var i = h(e, n, !0) || e[n.attributesKey] && "preserve" === e[n.attributesKey]["xml:space"]; if (i || (i = "ftef" in n ? n.ftef(t, e) : n.ft), !i) return c.push("/>"), c.join(""); c.push(">") } return c.push(s(e, n, r + 1, !1)), cE = e, cN = t, t && c.push((a ? y(n, r, !1) : "") + "</" + t + ">"), c.join("") } function s(e, n, r, c) { var i, s, u, o = []; for (s in e) if (e.hasOwnProperty(s)) for (u = a(e[s]) ? e[s] : [e[s]], i = 0; i < u.length; ++i) { switch (s) { case n.declarationKey: o.push(p(u[i], n, r)); break; case n.instructionKey: o.push((n.indentInstruction ? y(n, r, c) : "") + g(u[i], n, r)); break; case n.attributesKey: case n.parentKey: break; case n.textKey: o.push((n.indentText ? y(n, r, c) : "") + j(u[i], n)); break; case n.cdataKey: o.push((n.indentCdata ? y(n, r, c) : "") + m(u[i], n)); break; case n.doctypeKey: o.push(y(n, r, c) + l(u[i], n)); break; case n.commentKey: o.push(y(n, r, c) + b(u[i], n)); break; default: o.push(y(n, r, c) + t(u[i], s, n, r, h(u[i], n))) }c = c && !o.length } return o.join("") } function js2x(e, t) { t = v(t); var n = []; return cE = e, cN = "_root_", t.compact ? n.push(s(e, t, 0, !0)) : (e[t.declarationKey] && n.push(p(e[t.declarationKey], t, 0)), e[t.elementsKey] && e[t.elementsKey].length && n.push(writeElements(e[t.elementsKey], t, 0, !n.length))), n.join("") } function j2x(e, t) { e instanceof Buffer && (e = e.toString()); if ("string" == typeof e) try { JSON.parse(e) } catch (e) { throw new Error("invalid JSON") } else e; return js2x(e, t) } pOptions.hasOwnProperty("compact") || (pOptions = Object.assign({ compact: !0 }, pOptions));
    return j2x(pJson, pOptions);
}